export function debounce (callback: Function, delay: number) {
    let timer: NodeJS.Timeout;
    return (...args: any) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            callback(...args);
        }, delay);
    }
}

// В представленной функции debounce используется замыкание для сохранения и обновления переменной timer между последовательными вызовами функции, возвращаемой внутренней функцией debounce.
//
//     Замыкание в JavaScript возникает тогда, когда функция имеет доступ к своей внешней области видимости, даже после того как функция была возвращена из этой области видимости. В случае с debounce, внутренняя функция, которая использует переменную timer и была возвращена из внешней функции debounce, устанавливается замыкание, позволяющее сохранять значение timer между вызовами внутренней функции.
//
//     При первом вызове debounce, timer инициализируется как undefined. Когда возвращенная функция вызывается, она имеет доступ к переменной timer через замыкание, что позволяет ей удалять предыдущий таймаут, сохраненный в timer, перед установкой нового таймаута с обратным вызовом callback.
//
//     Таким образом, при последующих вызовах возвращенной функции, она продолжает иметь доступ к переменной timer через замыкание, позволяя инициировать новую установку таймаута или удаление предыдущего значения timer.
//
//     С использованием замыкания в этой функции debounce, значение timer сохраняется и обновляется между последовательными вызовами функции, обеспечивая правильное поведение задержки вызова переданной функции callback.